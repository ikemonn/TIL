## プロセススケジューリング

### プロセスとは
- 各々のプロセスはプロセス固有のコンテクストを持つ
  - プロセス空間
  - レジスタ値等
- 個々のプロセスに関する情報はtask_struct(task_t型)構造体で管理されている
- スレッドもプロセスの一種
  - スレッド同士が同じプロセス空間を共有している
  - プロセススケジューリングからはどちらも同じものとして扱われる

## プロセス切り替え
- プロセスのコンテキストを切り替え先のプロセスのものに書き換えればプロセスは切り替わる
  - プロセス空間管理レジスタ
  - プログラムカウンタ
  - スタックポインタ
  - 各種演算用レジスタ
- 実行待ち状態のプロセスは、上記のプロセスコンテキストをtask_struct構造体やカーネルスタックに退避しておく
  - 実行タイミングでCPU上に読み込む

## プロセスディスパッチャの実装
### context_switch関数
- プロセスディスパッチャのコードはcontext_switch関数にある

```
task_t * context_switch(runqueue_t *rq, task_t *prev, task_t *next)
{
  struct mm_struct *mm = next->mm;
  struct mm_struct *oldmm = prev->active_mm;

  if(unlikely(!mm)) {
    next->active_mm = oldmm;
    atomic_inc(&oldmm->mm_count);
    enter_lazy_tlb(oldmm, next);
  } else {
    switch_mm(oldmm, mm, next);

    if (unlikely(!prev->mm)) {
      prev->active_mm = NULL;
      WARN_ON(rq->prev_mm);
      rq->prev_mm = oldmm;
    }
    switch_to(prev, next, prev);
    return prev;
  }
}
```

```
#define switch_to(prev,next,last) do {					\
	unsigned long esi,edi;						\
	asm volatile("pushl %%ebp\n\t"					\
		     "movl %%esp,%0\n\t"	/* save ESP */		\
		     "movl %5,%%esp\n\t"	/* restore ESP */	\
		     "movl $1f,%1\n\t"		/* save EIP */		\
		     "pushl %6\n\t"		/* restore EIP */	\
		     "jmp __switch_to\n"				\
		     "1:\t"						\
		     "popl %%ebp\n\t"					\
		     :"=m" (prev->thread.esp),"=m" (prev->thread.eip),	\
		      "=a" (last),"=S" (esi),"=D" (edi)			\
		     :"m" (next->thread.esp),"m" (next->thread.eip),	\
		      "2" (prev), "d" (next));				\
} while (0)
```
- EIPレジスタ(命令ポインタ)
- ESPレジスタ(スタックポインタ)


## プロセススケジューラ
- プロセスディスパッチャは指定されたプロセスにCPUを割り当てる作業を行う
  - どのプロセスに実行権を与えるかの判断は行わない
- 実行可能なプロセス群全体を監視し、いつどのプロセスに実行権を与えるかを判断し、プロセスディスパッチャに切り替え要求を出すのがプロセススケジューラ

### 優先度の指標
- 各プロセスは実行優先度としてniceコマンドで指定する固定優先度の他に、変動優先度をもつ
  - カーネルは経過時間とともにプロセスの変動優先度を変更し、固定優先度+変動優先度の合計が最も大きいプロセスに実行権を与える
  - より多くCPUを使用したプロセスほど低い変動優先度を持ち、shellのような対話型プロセスはあまりCPUを使用しないため高い変動優先度をもつ
- 実行中のプロセスから実行権を奪い取ることを「プリエンプトする」という

### マルチプロセッサシステムにおけるプロセススケジューリング
- あるプロセスが、あるCPUで起動した場合、そのプロセスが利用した実メモリの内容がキャッシュメモリに蓄えられているため、次回以降も同じCPUで起動させたほうが良い
  - Linux2.6のプロセススケジューラは各CPU上でそれぞれ独立して動作しており、それぞれのCPUで動作するのに最も適したプロセスを選択する
  - プロセスはどこかのCPUに括りつけるようになっていて、CPU負荷のバランスが大きく崩れた時のみ別のCPUで再スケジューリングする

## プロセススケジューラの実装
### 実行優先度ごとのRUNキュー
- 実行可能なプロセスはRUNキューに登録される
- RUNキューには2種類ある
  - activeキュー、expiredキュー
- activeキュー
  - 実行可能で、実行割当時間を持っているプロセス
- expiredキュー
  - 実行可能状態だが、実行割当時間を使い果たしてしまったプロセス
- activeキューの中身がなくなったら、expiredキューと交換して処理を継続する
### CPU毎のRUNキュー
- RUNキュー(active/expired)はCPU毎にある
- RUNキュー間で負荷状態に偏りが出た時は、RUNキュー間で実行待ちプロセスの移動を行いバランスをとる
- プロセス起動時にアイドル状態のプロセッサにそのプロセスを割り当てる

### アイドルプロセス
- CPUがアイドル状態になった時に実行権を与えるプロセス
  - 別の実行可能なプロセスが現れてプリエンプとされるのを待ち続ける
- 各CPUに１つ用意されており、RUNキューには登録されない

# プロセス管理
## プロセスモデル
### プロセス
- 同一メモリ空間など処理に必要なリソースを共有する1つ以上のスレッドからなる
- スレッドグループ

### ユーザスレッド
- 一般的にスレッドと呼ばれるもの
- 1プロセス内で複数の処理を同時に実行できる独立した実行単位
- 1つのプロセスは複数のスレッドが実行でき、プロセウに属するスレッド同士は単一のメモリ空間を共有する

### スレッドグループ
- メモリ空間とシグナルハンドラなどを共有するプロセスの集まり
- スレッドグループリーダをもつ
- ユーザから見た場合の「プロセス」はスレッドグループを指すことが多い

### LWP (Light Weight Process)
- カーネルがサポートする単位でカーネルスレッドとも呼ばれる
- ユーザ空間で実行されるプロセスは、カーネル内ではLWPという単位で実行される
- ユーザスレッドとLWPが1:1で対応する

### カーネルスレッド
- LWPの項で説明したカーネルスレッドとは別物
- カーネルデーモンと呼ばれることもある
- カーネル空間でのみ実行される

## プロセスに関するデータ構造
- Linuxは実行する基本的な単位をプロセスとしている
- それらに関する情報をtask_struct構造体に格納している
- カネールコードをじっこうするためのスタックと低レベルのフラグはthread_info構造体に収められている

### 状態遷移のフラグ
- task_struct構造体のstateメンバとexit_stateメンバがプロセスの実行状態を表す

#### TASK_RUNNING
- あるCPUで実行中か、実行可能でCPU割当を待っている状態

#### TASK_INTERRUPTIBLE/TASK_UNINTERRUPTIBLE
- 何らかの事象(ユーザからの入力やディスクI/O完了待ちなど)を待っている状態
- TASK_INTERRUPTIBLEはシグナルを受信すると待機状態を終了する
- TASK_UNINTERRUPTIBLEはそのまま待ち続ける
- 待っている事象がユーザの入力待ちや、パイプやネットワークからのデータの到着待ちなど比較的時間がかかる処理の場合には途中で処理を中断できたほうがよいので、TASK_INTERRUPTIBLEが使用される
- Ctrl+CやCtrl+Zを使えるのはTASK_INTERRUPTIBLEが使用されているから

#### TASK_STOPPED
- シグナルSIGSTOPなどを受信したり、ptraceシステムコールで一旦処理を停止している状態

#### TASK_TRACED
- ptraceによりトレース対象になっている状態

#### TASK_NONINTERACTIVE
- 非対話的処理を示し、スケジューラへのヒントとして使われる

#### EXIT_ZOMBIE
- プロセスが処理を終了し、親プロセスが終了コードを取得するのを待っている状態

#### EXIT_DEAD
- プロセスが処理を終了したが、終了コードを保持しておく必要がないときとる状態
- すぐに開放可能なtask_structを保持していることを示し、waitの競合状態を回避するために使用されている

## 複数のプロセスを管理するグループ
### プロセスグループ、セッションと制御端末
- プロセスグループ
  - ある処理やアプリケーションに関連したプロセス(スレッドグループ)の集まりでプロセスグループリーダーとなるプロセスを持つ
- セッション
  - 制御端末に関連付けられたものでセッションリーダと呼ばれる１つの制御プロセスを持ち、１つ以上のプロセスグループから構成される
- １つの制御端末では複数プロセスグループが動作可能だが、端末への入出力は１つのプロセウスグループのみ可能
- 端末への入出力が可能なプロセスグループを「フォアグラウンド」状態といい、そうではないものを「バックグランド」状態と呼ぶ
- 典型的にはセッションとは、シェルとそのシェル上で動作しているジョブであり、セッションリーダはシェル
  - プロセスグループはシェルのパイプでつながれたプロセス群

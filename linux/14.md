# ページの回収処理
## 基本戦略
- 回収処理の対象
  - プロセス空間で使用している実ページとページキャッシュ(ファイルキャッシュ)で使用している実ページ
  - カーネルで使用している実ページは回収対象にならない
- 回収戦略
  - 最近使っていない実ページを回収する

## 回収対象ページの管理構造
- 回収対象ページも利用可能な実ページの管理と同様にゾーンごとに管理されている
- 回収対象ページを管理するためにzone構造体のactive_list,inactive_listメンバーをデータ構造として使う

- activeリスト
  - 最近アクセスされた実ページ
- inactiveリスト
  - 最近アクセスされていないページ
- デマンドページングにより空きページが始めてプロセス空間やファイルキャッシュとして割り当てられた時はactive_listにつながれる
- 最近アクセスされていないものをinactiveリストにつなぐのが回収の仕事

### 最近アクセスされたかの判断3パターン
#### 1. ページキャッシュとして使用され、プロセス空間にはマップされていない
- page構造体のPG_referencedフラグが使用される
- ページキャッシュにアクセスがあるとPG_referencedフラグを立てる
  - 回収処理はPG_referencedを見ることで最近アクセスされたかが分かる

#### 2. プロセス空間にマップされ、ページキャッシュではない
- 無名ページと呼ばれる
- ページへのアクセスはカーネルが感知できないところで行われている
  - アクセスされたかはページテーブルに(ハードウェアによって)記録される
  - アクセスされたかをページテーブルのエントリを参照して判断する

#### 3. ページキャッシュでありプロセス空間にもマップされている
- ページキャッシュとしてアクセスされたかはPG_referencedフラグを見れば分かる
  - しかし、プロセス空間としてアクセスされる場合もあるので、やはりページテーブルエントリを探す手段が必要

## 回収処理の実体と実行の契機
- 回収処理の実体は2つある
  - 1. kswapdデーモン
    - カーネル内のスレッドでノード毎に存在している
    - 普段はずっと寝ているが残りページが少なくなった時にバディシステムから起こされる
    - 回収処理の契機はゾーンの残りページが閾値以下になること
  - 2. try_to_free_pages関数
    - 本当に残りページが少なくなってきた時に呼ばれる関数で閾値の判定をせずに回収処理を始める
      - バディシステムとバッファアロケータの２箇所からしか呼び出されない
## 回収処理の実装
- 大きく2つのフェーズがある
  - activeキューからinactiveキューへの移動
    - refill_inactive_zone関数で行う
  - inactiveキューからページを選択し、解放する
- shrink_cache関数がinactiveリストの後ろから一定量を取り出してshrink_list関数に渡す
  - shrink_list関数が実際に解放に必要な処理をおこなう



  

# プロセス空間の管理
## 基本テクニック
### スワップ
- 仮想ページには必ず実ページが対応しているわけではない
  - ディスクなどの2次記憶装置に格納されていることもある
- ある時点でプロセスがアクセスするアドレス範囲は限られている
  - 最近アクセスされた仮想ページのみを実メモリに置いておき、ほかは2次記憶装置に置いておく
    - こうすることで実際に搭載されているメモリよりも大きなメモリを使用しているように見せかけることができる
- ↑をスワップという

- 対応する実ページがない仮想ページにアクセスするとハードウェアは例外(ページフォルト)を発行してカーネルに知らせる
  - カーネルはその例外処理で実ページを割当ててスワップデバイスからデータを読み込み、プロセスに制御を戻す

### デマンドページング
- メモリが必要になった時点で実ページを割り当てること
- ヒープ領域の拡張の場合
  - プロセスがbrkシステムコールを発行するとヒープ域の拡張が行われる
  - カーネルはbrk値のみを更新して実ページは割り当てない
  - 実ページを割り当てるのはプロセスが実際に仮想ページにアクセスした時
  - 実ページがないのでページフォルトが発生する
  - この例外処理の中で新しいbrk値とひかくして不正なアドレスでないことを確認し、実ページを割り当てる

### コピーオンライト
- もともとfork処理のために編み出された
- プロセスをforkすると子プロセスのプロセス空間は親プロセスのプロセス空間をコピーしたものになる
  - 初期のUNIXでは子プロセスに実ページを割り当てていたが、実際に子プロセスがページにアクセスするとは限らない
  - 現在はfork発行時にはページテーブルをコピーするだけで実際にはメモリを確保しない
    - 必要になってからメモリをコピーする
  - このとき親子ともライトアクセスを禁止するように設定しておく
  - 親子どちらでもライトアクセスを行うと例外が発生し、その例外の中で実ページを割り当てる

### ファイルマップ
- mmapシステムコールをしようするとファイルの一部をプロセス空間にマップして、メモリの一部のようにアクセスできる
  - この機能がファイルマップ
- 通常の場合
  - ファイルのアクセスにはread/writeシステムコールを使用する
  - この時カーネルはファイルのデータをカーネルのバッファ(ﾌｧｲﾙｷｬｯｼｭ)にコピーした上でプロセス空間にコピーする
  - バッファをページ単位にし、そのページをプロセス空間にマップしてはどうかというのがファイルマップのアイデア
- つまり、ファイルのデータをメモリのデータと同じようにポインタで参照変更できるようにしたもの


## 制御構造
### mm_struct
- プロセス空間を管理する大本の制御表
- mm_structは1つのプロセス空間を表す
- プロセスごとに必要なので、task_structからポイントされている


## プロセス空間処理の実装
### fork
- mm_structとvm_area_structはプロセス生成時に割り当てられる
  - 親プロセスのものが子プロセスにコピーされる
  - 実際に処理を行っているのはcopy_mm関数
  - プロセス空間を共有する(スレッドを生成する場合)はmm_structを共有するため、mm_users(構造体を使用しているプロセス数)をインクリメントするだけ

## その他のトピック
### 共有メモリ
- Linuxにもプロセス間でメモリを共有する機能が提供されている
  - mmapとSystemVインターフェースを利用するやり方の2種類
- mmapの方
  - tmpfsを利用する
    - これはデータブロックとして実ページを使用する特殊なファイルシステム
    - システムがシャットダウンするとデータは消える
    - プロセス間でメモリを共有するにはまずtmpfs上にファイルを作成し、そのファイルに対して各プロセスがmmapシステムコールを発行する

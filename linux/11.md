# 実メモリの管理

## 制御構造
### page構造体
- page構造体はページの状態を管理する
- ページ1つにつき1つ存在している
- ページフレーム番号をインデックスとする配列に鳴っている
  - ページフレーム番号からpage構造体を求められるようにするため

### zone構造体
- ページはアドレスの範囲によって4つのゾーンに分類される


### pglist_data構造体
- ノード毎のメモリを管理するための制御表
  - ノードとはシステム内のメモリを分類し、メモリの割り当て方に差をつけるもの

## 空きページの管理
- 空きページはバディシステムと呼ばれる仕組みで管理されている

### バディシステム
- 空きページを2のべき乗の単位で管理する
  - 空きページを1ページ、2ページ、4ページ単位…みたいな感じ
- 連続する空きページはできるだけ大きな単位で取れるが、そのオーダーのページ境界にあった形にまとめているところがポイント

### 制御構造
- バディシステムの制御構造はzone構造体のfree_areaメンバで表される

```
struct free_area free_area[MAX_ORDER]
```

- 配列のインデックスは指数(オーダー)に対応し、例えばfree_area[2]は4ページ単位の管理を行うための構造体になる
- バディは片割れという意味で、一つ上のオーダーにまとめるときの相棒を意味する
  - オーダー0の時ページ0のバディはページ1

### 割りあて、解放の流れ
- 4ページの連続したページを確保したい場合
  - オーダー2(free_area[2])のfree_listをみる
  - free_listに空きページが繋がっていればそれを返す
  - 空きがなければ1つ上のオーダー(free_area[3])のfree_listをみる
  - free_listに繋がっていればそれを獲得し、2つに分割して片割れの一方をオーダー2のfree_listにつなぎ片割れの一方を返す
  - オーダー3にも空きがなければもう一つ上のオーダーを見に行く
  - これを再帰的に繰り返す
- ページフレーム12から始まる4ページを開放する場合
  - 出来る限り上のオーダーにまとめようとする
  - オーダーは2なのでfree_area[2]に返すところだが、まずバディがいるかを確認する
    - いれば片割れをfree_listから外し、もう一つ上のオーダーへの解放を試みる
    - いなければfree_listにつなぐ
